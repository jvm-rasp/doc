## 类加载器的实现类

ClassLoader是一个抽象类，它的实现类有很多，包括上一节中自定义的NetworkClassLoader，
还有JDK的URLClassLoader、AppClassLoader和ExtClassLoader等(jdk9以上类加载器实现有差异)。
一般我们只需要重写ClassLoader的findClass方法获取需要加载的类的字节码，
然后调用defineClass方法生成Class对象。
如果想要在类加载到JVM中时就被链接，可以调用resolveClass方法，也可以选择交给JVM在类初始化时链接。

（提供绘图的源码）

![JDK8上的ClassLoader的实现类继承关系](./Classloader-UML.png)

### URLClassLoader

URLClassLoader是ClassLoader的一个重要子类，它用于Jar文件和目录的URL的搜索路径加载类和资源。
它重写了findClass方法，findClass方法的作用就是从指定的url中去尝试加载类。
也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。
而class文件一般以jar包形式存在，因此使用URLClassLoader可以完成绝大多数场景的类和资源加载。

URLClassLoader的构造器参数是资源路径和父类加载器，构造器中主要是初始化URLClassPath对象。
```java
public URLClassLoader(URL[] urls, ClassLoader parent) {
    super(parent);
    // ... 权限检查代码省略
    this.acc = AccessController.getContext();
    ucp = new URLClassPath(urls, acc);
}
```

下面是findClass的实现。
```java
protected Class<?> findClass(final String name) throws ClassNotFoundException {
    // 1、将类的全限定名变成.class文件路径的方式
    String path = name.replace('.', '/').concat(".class");
    // 2、在url中查找是否存在
    Resource res = ucp.getResource(path, false);
    // ... 异常处理忽略
    return defineClass(name, res);
}
```

findClass方法的执行逻辑主要分为三步：

1、将类的全限定名变成.class文件路径的方式

2、在url中查找文件是否存在

3、调用defineClass

