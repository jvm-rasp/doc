## 9.1 Java 命令执行

### 9.1.1 命令执行API

java命令执行方式如下：

+ java.lang.Runtime.exec()
+ java.lang.ProcessBuilder.start()
+ java.lang.ProcessImpl.start()
+ JNI的方式调用动态链接库（该方式属于JNI注入，这里暂不做分析）

在Java中执行命令用使用最多的API是`Runtime.exec`，用法如下：
```java
public class Main {
    public static void main(String[] args) throws Exception {
        Runtime.getRuntime().exec("touch /tmp/1.txt");
    }
}
```

实际上Runtime类的exec的重载方法有6个，如下所示：
```java
public Process exec(String command)
public Process exec(String command, String[] envp)
public Process exec(String command, String[] envp, File dir)
public Process exec(String cmdarray[])
public Process exec(String[] cmdarray, String[] envp)
public Process exec(String[] cmdarray, String[] envp, File dir)
```

重载方法最终会实际调用上面中的最后一个方法，因此这里仅介绍其中的两个方法。
```java
public Process exec(String command, String[] envp, File dir)
    throws IOException {
    if (command.length() == 0)
    throw new IllegalArgumentException("Empty command");
    // 将字符串解析为token流
    StringTokenizer st = new StringTokenizer(command);
    String[] cmdarray = new String[st.countTokens()];
    for (int i = 0; st.hasMoreTokens(); i++)
    cmdarray[i] = st.nextToken();
    return exec(cmdarray, envp, dir);
}
```
command一个字符串，会解析为token流；
envp是字符串数组，其中每个元素的环境变量设置格式为name=value，
如果子进程的环境变量与当前进程一致，则为null；
dir：子进程的工作目录，如果子进程的工作目录与当前进程一致，则为null；

所有命令执行的方法最终会调用下面的方法。
```java
public Process exec(String[] cmdarray, String[] envp, File dir)
    throws IOException {
    return new ProcessBuilder(cmdarray)
        .environment(envp)
        .directory(dir)
        .start();
}
```
命令执行调用 ProcessBuilder 完成命令执行。

### 9.1.2 底层调用链路

常用的命令执行API 是java.lang.Runtime.exec()和java.lang.ProcessBuilder.start()，
除此之外，还有更为底层的java.lang.ProcessImpl.start()，如果阻断命令执行的调用过程，会抛出如下栈。

![rce/rce_strace.png](../../.vuepress/public/images/algorithm/rce/img.png)


![rce/java_exec.png](../../.vuepress/public/images/algorithm/rce/java_exec.png)

其中，ProcessImpl类是Process抽象类的具体实现，且该类的构造函数使用private修饰，所以无法在java.lang包的外部直接调用，只能通过反射调用ProcessImpl#start()方法执行命令。

这3种执行方法如下：

```java
import java.lang.reflect.Method;
import java.util.Map;

public class Main {
    public static void main(String[] args) throws Exception {

        // 定义命令方式
        String command = "touch /tmp/1.txt /tmp/2.txt /tmp/3-tools.txt";
        String[] commandarray = {"touch", "/tmp/1.txt", "/tmp/2.txt", "/tmp/3-tools.txt"};

        // 命令执行方式1
        Runtime.getRuntime().exec(command);

        // 命令执行方式2
        new ProcessBuilder(commandarray).start();

        // 命令执行方式3
        Class clazz = Class.forName("java.lang.ProcessImpl");
        Method method = clazz.getDeclaredMethod("start", new String[]{}.getClass(), Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class);
        method.setAccessible(true);
        method.invoke(null, commandarray, null, ".", null, true);
    }
}
```

1.exec方法最终执行了 `new ProcessBuilder(cmdarray).start()` 方法

![img.png](../../.vuepress/public/images/algorithm/rce/ProcessBuilder_exec.png)

2.ProcessBuilder.start 最终执行了 `ProcessImpl.start()`

![img.png](../../.vuepress/public/images/algorithm/rce/ProcessImpl_start.png)

3.ProcessImpl.start() 调用了 new UNIXProcess()
![img.png](../../.vuepress/public/images/algorithm/rce/UNIXProcess_exec.png)

至此 java 层面的方法分析完毕。

### 9.1.3 HOOK类选择
传统RASP一般会选择如下2个类，即java.lang.ProcessImpl(JDK9以上)、java.lang.UNIXProcess(JDK8以下)

上面的方法都是Java层面的, 最终的都会调用到native方法：`forkAndExec`。
+ 在JDK8以下，这个方法在`java.lang.UNIXProcess`类中
+ 在JDK9以上，这个方法在`java.lang.ProcessImpl`类中。

如果任意代码执行时，反射执行native层面的方法，上面的hook点将被绕过。（绕过方式是unsafe+反射，这里不在细究）

因此，RASP对于命令执行的hook点选择应该是`forkAndExec`
