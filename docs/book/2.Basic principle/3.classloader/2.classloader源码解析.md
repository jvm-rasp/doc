## ClassLoader源码解析
有了上面的使用基础，再来分析下类加载器的源码。

### loadClass

ClassLoader是调用其loadClass(String, boolean)方法来加载class的，loadClass核心代码如下：
```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 1.从缓存中查找当前类
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    // 2.1 当前类加载器的父加载不为空，尝试从父类加载器加载
                    c = parent.loadClass(name, false);
                } else {
                    // 2.2 父加载器为空，使用启动类加载器加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 忽略 ClassNotFoundException 异常，继续查找
            }

            if (c == null) {
                // 3. 如果查找失败，调用当前类加载器重写的findClass查找
                c = findClass(name);
            }
        }
        
        // 链接类
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```
上面的类加载顺序可以总结为：
优先从尝试父加载器去加载（如果父加载器为null，则调用系统类加载器BootstrapClassLoader去加载），
父加载器都尝试失败后才会交由当前ClassLoader重写的findClass方法去加载。

### findClass
在加载class的过程中，如果父加载器都没有找到，则调用子类加载器重写的findClass方法继续查找，
findClass方法如下：
```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    // 调用时抛出异常  
    throw new ClassNotFoundException(name);
}
```
可以看到该方法里面抛出异常，因此不能直接调用，需要子类来实现。
在"ClassLoader基本方法和使用"一节中，
我们实现了一个类加载器并重写了findClass，使得该加载器可以从网络查找class文件。

### defineClass

defineClass与findClass一起使用，findClass负责读取自于磁盘或者网络的字节码流，
而defineClass将字节码流解析为Class对象， 
在defineClass方法中使用resolveClass方法完成对Class的链接。
```java
protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                     ProtectionDomain protectionDomain)
    throws ClassFormatError {
    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    return c;
}
```
defineClass的实现在defineClass1方法中，defineClass1是一个native方法，
具体实现hotspot中，实现较为复杂，一般不需要特别关注。


## ClassLoader的实现类

![ClassLoader的实现类](./Classloader-UML.png)

ClassLoader是一个抽象类，它的实现类有很多，包括上一节中自定义的NetworkClassLoader，
jdk自带的URLClassLoader、AppClassLoader、ExtClassLoader等(jdk9以上类加载器实现有差异)。
一般我们只需要重写ClassLoader的findClass方法获取需要加载的类的字节码，
然后调用defineClass方法生成Class对象。
如果想要在类加载到JVM中时就被链接，可以调用resolveClass方法，也可以选择交给JVM在类初始化时链接。

### URLClassLoader

URLClassLoader是ClassLoader的一个重要子类，它用于Jar文件和目录的URL的搜索路径加载类和资源。
它重写了findClass方法，findClass方法的作用就是从指定的url中去尝试加载类。
也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。
而class文件一般以jar包形式存在，因此使用URLClassLoader可以完成绝大多数场景的类和资源加载。

URLClassLoader的构造器参数是资源路径和父类加载器，构造器中主要是初始化URLClassPath对象。
```java
public URLClassLoader(URL[] urls, ClassLoader parent) {
    super(parent);
    // this is to make the stack depth consistent with 1.1
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkCreateClassLoader();
    }
    this.acc = AccessController.getContext();
    ucp = new URLClassPath(urls, acc);
}
```

下面是findClass的实现。
```java
protected Class<?> findClass(final String name) throws ClassNotFoundException {
    final Class<?> result;
    try {
        result = AccessController.doPrivileged(
            new PrivilegedExceptionAction<Class<?>>() {
                public Class<?> run() throws ClassNotFoundException {
                    // 1、将类的全限定名变成.class文件路径的方式
                    String path = name.replace('.', '/').concat(".class");
                    // 2、在url中查找是否存在
                    Resource res = ucp.getResource(path, false);
                    if (res != null) {
                        try {
                            //3、如果存在则加载该类
                            return defineClass(name, res);
                        } catch (IOException e) {
                            throw new ClassNotFoundException(name, e);
                        }
                    } else {
                        return null;
                    }
                }
            }, acc);
    } catch (java.security.PrivilegedActionException pae) {
        throw (ClassNotFoundException) pae.getException();
    }
    if (result == null) {
        throw new ClassNotFoundException(name);
    }
    return result;
}
```
findClass方法的执行逻辑主要分为三步：

1、将类的全限定名变成.class文件路径的方式
2、在url中查找文件是否存在
3、如果存在则加载该类并调用defineClass
