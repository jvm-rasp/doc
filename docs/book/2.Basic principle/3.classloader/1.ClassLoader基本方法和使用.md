## ClassLoader基本方法和使用

ClassLoader是一个抽象类，不能直接使用，因此我们经常会继承它并重写其中的重要方法。它的主要方法有defineClass、loadClass、findClass和resolveClass等及其重载方法。
```java
 // 方法的输入是字节码的byte数组，输出是Class对象，它的作用是将别字节码数组解析JVM能够识别的Class对象
 protected final Class<?> defineClass(String name, byte[] b, int off, int len)
 
 // 通过类名称查找Class对象
 public Class<?> loadClass(String name)
 
 // 通过类权限定名称加载类
 protected Class<?> findClass(String name)

 // 调用该方法完成类的链接过程
 protected final void resolveClass(Class<?> c)
```

先来实现一个简单的类加载器， 这个类加载器具备从网络加载类文件的能力，实现代码如下：
```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 下载地址
        String baseUrl = "https://wwww.jrasp.com";
        // 初始化网络类加载器
        NetworkClassLoader loader = new NetworkClassLoader(baseUrl);
        // 加载位于 https://wwww.jrasp.com/Foo.class的类，并创建实例
        Object foo = loader.loadClass("Foo").newInstance();
    }
}
```

其中 NetworkClassLoader 实现如下：
```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

public class NetworkClassLoader extends ClassLoader {
    
    // 类下载地址
    private String downloadUrl;

    public NetworkClassLoader(String downloadUrl) {
        this.downloadUrl = downloadUrl;
    }

    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return super.loadClass(name, true);
    }
    
    // 实现类的查找方法
    @Override
    public Class findClass(String name) {
        byte[] b = loadClassData(name);
        return defineClass(name, b, 0, b.length);
    }
    
    // 从远程下载类文件，从而获得类的字节码数组
    private byte[] loadClassData(String name) {
        // load the class data from the connection
        InputStream input = null;
        ByteArrayOutputStream baos = null;
        String path = classNameToPath(name);
        try {
            URL url = new URL(path);
            byte[] buff = new byte[1024 * 4];
            int len = -1;
            input = url.openStream();
            baos = new ByteArrayOutputStream();
            while ((len = input.read(buff)) != -1) {
                baos.write(buff, 0, len);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (input == null) {
                try {
                    input.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return baos.toByteArray();
    }
    
    // 类名称转化为服务器下载的地址
    private String classNameToPath(String name) {
        return donwloadUrl + "/" + name.replace(".", "/") + ".class";
    }
}
```

被加载的类Foo是一个简单类，在创建实例对象时输出create a new instance of Foo class，Foo类的代码如下：
```
public class Foo {
    public Foo() {
        System.out.println("create new instance");
    }
}
```

运行Main方法，输出结果如下：
```text
create new instance
```

ClassLoader中主要是完成类查找、加载和链接等过程，其中还有一些方法如getResourceAsStream方法，可以用来加载文件资源，如读取jar包中的配置文件等，如下面的例子：
```java
public static void main(String[] args) throws Exception {                         
    String baseUrl = "https://wwww.jrasp.com";                                    
    NetworkClassLoader loader = new NetworkClassLoader(baseUrl);                  
    ByteArrayOutputStream bos = new ByteArrayOutputStream();  
    // 读取jar包的META-INF/MANIFEST.MF文件
    InputStream stream = loader.getResourceAsStream("META-INF/MANIFEST.MF");      
    byte[] buffer = new byte[1024];                                               
    int len = 0;                                                                  
    while ((len = stream.read(buffer)) != -1) {                                   
        bos.write(buffer, 0, len);                                                
    }                                                                             
    stream.close();                                                               
    bos.close();                                                                  
    System.out.println(bos);                                                      
}                                                                                                                                                                                                                                                    
```

运行上面的代码输出如下
```text
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.8.4
Created-By: 1.6.0_65-b14-468 (Apple Inc.)
```
