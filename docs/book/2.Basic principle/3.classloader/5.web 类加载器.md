## web类加载器

前面介绍了java中类加载的一般模型：双亲委派模型，这个模型适用于大多数类加载的场景，
但对于web容器却是不适用的；这是因为servlet规范对web容器的类加载做了一些规定，简单的来说有以下几条：

1.WEB-INF/classes和WEB-INF/lib路径下的类会优先于父容器中的类加载，比如WEB-INF/classes下有个ABC类，CLASSPATH下也有个ABC类，jetty会优先加载WEB-INF/classes下的，这与双亲委托模型下的加载行为相反。
2.java.lang.Object等系统类不遵循第一条， WEB-INF/classes或WEB-INF/lib中的类不能替换系统类。对于哪些是系统类，其实没有做出具体规定，jetty中是通过枚举了一些类来进行判断的。
3.Server容器的实现类不被应用中的类引用，即Server的实现类不能被任何应用类加载器加载。对于哪些是系统类，也是通过枚举类的全限定名来实现的。

### jetty

为了实现上面的三个要求并实现不同部署应用间依赖的隔离，jetty定义了自己的类加载器WebAppClassLoader，通过对这个类加载器使用线程上下文加载模式来达到目的。

WebAppClassLoader的属性
```text
    private final Context _context;     // 类加载器上下文
    private final ClassLoader _parent;  // 父加载器
    private final Set<String> _extensions = new HashSet<String>(); // 加载文件的后缀
    private String _name = String.valueOf(hashCode()); // 加载器名称
    private final List<ClassFileTransformer> _transformers = new CopyOnWriteArrayList<>(); // 类加载之前转换器
```

jetty规定的系统类和jetty自身的基础类如下，如果是这些类将不使用WebAppClassLoader加载

```text
    // System classes are classes that cannot be replaced by
    // the web application, and they are *always* loaded via
    // system classloader.
    public static final ClassMatcher __dftSystemClasses = new ClassMatcher(
        "java.",                            // Java SE classes (per servlet spec v2.5 / SRV.9.7.2)
        "javax.",                           // Java SE classes (per servlet spec v2.5 / SRV.9.7.2)
        "org.xml.",                         // javax.xml
        "org.w3c."                          // javax.xml
    );

    // Server classes are classes that are hidden from being
    // loaded by the web application using system classloader,
    // so if web application needs to load any of such classes,
    // it has to include them in its distribution.
    public static final ClassMatcher __dftServerClasses = new ClassMatcher(
        "org.eclipse.jetty."                // hide jetty classes
    );

    private final ClassMatcher _systemClasses = new ClassMatcher(__dftSystemClasses);
    private final ClassMatcher _serverClasses = new ClassMatcher(__dftServerClasses);

```

判断是否是parent优先模式由WebAppContext中的一段来解决：
```text
    private boolean _parentLoaderPriority = Boolean.getBoolean("org.eclipse.jetty.server.webapp.parentLoaderPriority");
     
     /**
     * @return True if the classloader should delegate first to the parent
     * classloader (standard java behaviour) or false if the classloader
     * should first try to load from WEB-INF/lib or WEB-INF/classes (servlet
     * spec recommendation). Default is false or can be set by the system
     * property org.eclipse.jetty.server.webapp.parentLoaderPriority
     */
    @Override
    @ManagedAttribute(value = "parent classloader given priority", readonly = true)
    public boolean isParentLoaderPriority()
    {
        return _parentLoaderPriority;
    }
```

构造器
```text
    public WebAppClassLoader(Context context)
        throws IOException
    {
        this(null, context);
    }
    
    // 父加载器
    // 加载器上下文 
    public WebAppClassLoader(ClassLoader parent, Context context)
        throws IOException
    {
        super(new URL[]{}, parent != null ? parent
            : (Thread.currentThread().getContextClassLoader() != null ? Thread.currentThread().getContextClassLoader()
            : (WebAppClassLoader.class.getClassLoader() != null ? WebAppClassLoader.class.getClassLoader()
            : ClassLoader.getSystemClassLoader())));
        // 如果在构建的时候没有提供父亲classLoader，那么将会默认将当前的线程classLoader作为当前的父classLoader      
        _parent = getParent(); // 获取上面设置的父加载器
        _context = context; // 保存上下文
        if (_parent == null)
            throw new IllegalArgumentException("no parent classloader!");
        
        // 类加载器可以加载的文件类型：jar或者zip包    
        _extensions.add(".jar");
        _extensions.add(".zip");

        if (context.getExtraClasspath() != null)
        {
            for (Resource resource : context.getExtraClasspath())
            {
                addClassPath(resource);
            }
        }
    }
```

其实这里一般情况下都是会调用第一个构造函数，
第二个构造函数可以显示指定父类加载器，这里默认是将当前的线程上下文classLoader指定为当前的parent，
而这个线程上下文classLoader如果没有用户指定的话默认又将是前面提到过的appClassLoader，也就是用于加载用户代码的classLoader。。。。

在看下 loadclass 方法：
```text
    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name))
        {
            ClassNotFoundException ex = null;
            Class<?> parentClass = null; // 来源于父加载器
            Class<?> webappClass = null; // 来源于webapp加载器

            // Has this loader loaded the class already?
            // 先从已经加载的类正经查找  
            webappClass = findLoadedClass(name);
            if (webappClass != null)
            {
                return webappClass;
            }

            // 是否父类加载器优先加载
            if (_context.isParentLoaderPriority())
            {
                // Try the parent loader
                try
                {   
                    // 从父类加载加载
                    parentClass = _parent.loadClass(name);
                    if (parentClass == null)
                        throw new ClassNotFoundException("Bad ClassLoader: returned null for loadClass(" + name + ")");

                    // If the webapp is allowed to see this class
                    // 如果设置了子类可以看见父类，返回父类
                    if (Boolean.TRUE.equals(__loadServerClasses.get()) || !_context.isServerClass(parentClass))
                    {
                        return parentClass;
                    }
                }
                catch (ClassNotFoundException e)
                {
                    // Save it for later
                    ex = e;
                }

                // Try the webapp loader
                try
                {
                    // 从类加载器的路径下查找类
                    webappClass = this.findClass(name);
                    if (resolve)
                        resolveClass(webappClass);
                    return webappClass;
                }
                catch (ClassNotFoundException e)
                {
                    if (ex == null)
                        ex = e;
                    else if (e != ex)
                        ex.addSuppressed(e);
                }

                throw ex;
            }
            else
            // 先从子类加载器加载
            {
                // Not parent loader priority, so...
                webappClass = loadAsResource(name, true);
                if (webappClass != null)
                {
                    return webappClass;
                }
                        
                // Try the parent loader
                // 子类未加载，父类加载器加载
                try
                {
                    parentClass = _parent.loadClass(name);
                    // If the webapp is allowed to see this class
                    if (Boolean.TRUE.equals(__loadServerClasses.get()) || !_context.isServerClass(parentClass))
                    {
                        return parentClass;
                    }
                }
                catch (ClassNotFoundException e)
                {
                    ex = e;
                }

                // We couldn't find a parent class, so OK to return a webapp one if it exists 
                // and we just couldn't see it before 
                webappClass = loadAsResource(name, false);
                if (webappClass != null)
                {
                    return webappClass;
                }

                throw ex == null ? new ClassNotFoundException(name) : ex;
            }
        }
    }
```

jar包添加
```text
    /**
     * Add elements to the class path for the context from the jar and zip files found
     * in the specified resource.
     *
     * @param lib the resource that contains the jar and/or zip files.
     */
    public void addJars(Resource lib)
    {
        if (lib.exists() && lib.isDirectory())
        {
            String[] entries = lib.list();
            if (entries != null)
            {
                Arrays.sort(entries);

                for (String entry : entries)
                {
                    try
                    {
                        Resource resource = lib.addPath(entry);
                        if (LOG.isDebugEnabled())
                            LOG.debug("addJar - {}", resource);
                        String fnlc = resource.getName().toLowerCase(Locale.ENGLISH);
                        // don't check if this is a directory (prevents use of symlinks), see Bug 353165
                        if (isFileSupported(fnlc)) // .jar、.zip
                        {
                            String jar = URIUtil.encodeSpecific(resource.toString(), ",;");
                            addClassPath(jar);
                        }
                    }
                    catch (Exception ex)
                    {
                        LOG.warn("Unable to load WEB-INF/lib JAR {}", entry, ex);
                    }
                }
            }
        }
    }
```

### tomcat




### springboot
