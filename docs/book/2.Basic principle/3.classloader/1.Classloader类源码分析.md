# 类加载器使用和源码解析

> 20230806

Classloader即是类加载，虚拟机把描述类的数据从class字节码文件加载到内存，
并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，
这就是虚拟机的类加载机制。 了解java的类加载机制，可以解决运行时的各种加载问题并快速定位其背后的本质原因， 也是解决疑难杂症的利器。

一般在开发web项目时很少直接使用类加载器，因为web中间件为我们屏蔽了类加载器的复杂性，而我们只需要实现具体的业务逻辑即可。
如果开发过Java中间件，你会发现类加载器使用非常频繁。
本章先介绍类加载器的API及使用，然后分析ClassLoader的源码实现，最后介绍热加载技术。

## ClassLoader 基本方法和使用

ClassLoader是一个抽象类，不能直接使用，因此我们经常会继承它并重写其中的重要方法。它的主要方法有defineClass、loadClass、findClass和resolveClass等及其重载方法。
```java
 // 方法的输入是字节码的byte数组，输出是Class对象，它的作用是将别字节码数组解析JVM能够识别的Class对象
 protected final Class<?> defineClass(String name, byte[] b, int off, int len)
 
 // 通过类名称查找Class对象
 public Class<?> loadClass(String name)
 
 // 通过类权限定名称加载类
 protected Class<?> findClass(String name)

 // 调用该方法完成类的链接过程
 protected final void resolveClass(Class<?> c)
```

先来实现一个简单的类加载器， 这个类加载器具备从网络加载类文件的能力，实现代码如下：
```java
public class Main {
    public static void main(String[] args) throws Exception {
        // 下载地址
        String baseUrl = "https://wwww.jrasp.com";
        // 初始化网络类加载器
        NetworkClassLoader loader = new NetworkClassLoader(baseUrl);
        // 加载位于 https://wwww.jrasp.com/Foo.clas 的类，并创建实例
        Object foo = loader.loadClass("Foo").newInstance();
    }
}
```
其中 NetworkClassLoader 实现如下：
```java
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

public class NetworkClassLoader extends ClassLoader {
    
    // 类下载地址
    private String downloadUrl;

    public NetworkClassLoader(String downloadUrl) {
        this.downloadUrl = downloadUrl;
    }

    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        return super.loadClass(name, true);
    }
    
    // 实现类的查找方法
    @Override
    public Class findClass(String name) {
        byte[] b = loadClassData(name);
        return defineClass(name, b, 0, b.length);
    }
    
    // 从远程下载类文件，从而获得类的字节码数组
    private byte[] loadClassData(String name) {
        // load the class data from the connection
        InputStream input = null;
        ByteArrayOutputStream baos = null;
        String path = classNameToPath(name);
        try {
            URL url = new URL(path);
            byte[] buff = new byte[1024 * 4];
            int len = -1;
            input = url.openStream();
            baos = new ByteArrayOutputStream();
            while ((len = input.read(buff)) != -1) {
                baos.write(buff, 0, len);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (input == null) {
                try {
                    input.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return baos.toByteArray();
    }
    
    // 类名称转化为服务器下载的地址
    private String classNameToPath(String name) {
        return donwloadUrl + "/" + name.replace(".", "/") + ".class";
    }
}
```

被加载的类Foo是一个简单类，在创建实例对象时输出create a new instance of Foo class，Foo类的代码如下：
```
public class Foo {
    public Foo() {
        System.out.println("create new instance");
    }
}
```

运行Main方法，输出结果如下：
```text
create new instance
```

ClassLoader中主要是完成类查找、加载和链接等过程，其中还有一些方法如getResourceAsStream方法，可以用来加载文件资源，如读取jar包中的配置文件等，如下面的例子：
```java
public static void main(String[] args) throws Exception {                         
    String baseUrl = "https://wwww.jrasp.com";                                    
    NetworkClassLoader loader = new NetworkClassLoader(baseUrl);                  
    ByteArrayOutputStream bos = new ByteArrayOutputStream();  
    // 读取jar包的META-INF/MANIFEST.MF文件
    InputStream stream = loader.getResourceAsStream("META-INF/MANIFEST.MF");      
    byte[] buffer = new byte[1024];                                               
    int len = 0;                                                                  
    while ((len = stream.read(buffer)) != -1) {                                   
        bos.write(buffer, 0, len);                                                
    }                                                                             
    stream.close();                                                               
    bos.close();                                                                  
    System.out.println(bos);                                                      
}                                                                                                                                                                                                                                                    
```

运行上面的代码输出如下
```text
Manifest-Version: 1.0
Ant-Version: Apache Ant 1.8.4
Created-By: 1.6.0_65-b14-468 (Apple Inc.)
```

## ClassLoader源码解析
有了上面的使用基础，再来分析下类加载器的源码。

### loadClass

ClassLoader是调用其loadClass(String, boolean)方法来加载class的，loadClass核心代码如下：
```java
protected Class<?> loadClass(String name, boolean resolve)
    throws ClassNotFoundException
{
    synchronized (getClassLoadingLock(name)) {
        // 1.从缓存中查找当前类
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            try {
                if (parent != null) {
                    // 2.1 当前类加载器的父加载不为空，尝试从父类加载器加载
                    c = parent.loadClass(name, false);
                } else {
                    // 2.2 父加载器为空，使用启动类加载器加载
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 忽略 ClassNotFoundException 异常，继续查找
            }

            if (c == null) {
                // 3. 如果查找失败，调用当前类加载器重写的findClass查找
                c = findClass(name);
            }
        }
        
        // 链接类
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```
上面的类加载顺序可以总结为：
优先从尝试父加载器去加载（如果父加载器为null，则调用系统类加载器BootstrapClassLoader去加载），
父加载器都尝试失败后才会交由当前ClassLoader重写的findClass方法去加载。

### findClass
在加载class的过程中，如果父加载器都没有找到，则调用子类加载器重写的findClass方法继续查找，findClass方法如下：
```java
protected Class<?> findClass(String name) throws ClassNotFoundException {
    // 调用时抛出异常  
    throw new ClassNotFoundException(name);
}
```
可以看到该方法里面抛出异常，因此不能直接调用，需要子类来实现。在"ClassLoader基本方法和使用"一节中，
我们实现了一个类加载器并重写了findClass，使得该加载器可以从网络查找class文件。 

### defineClass

defineClass与findClass一起使用，findClass负责读取自于磁盘或者网络的字节码流，
而defineClass将字节码流解析为Class对象， 在defineClass方法中使用resolveClass方法完成对Class的链接。
```java
protected final Class<?> defineClass(String name, byte[] b, int off, int len,
                                     ProtectionDomain protectionDomain)
    throws ClassFormatError
{
    protectionDomain = preDefineClass(name, protectionDomain);
    String source = defineClassSourceLocation(protectionDomain);
    Class<?> c = defineClass1(name, b, off, len, protectionDomain, source);
    postDefineClass(c, protectionDomain);
    return c;
}
```
defineClass的实现在defineClass1方法中，defineClass1是一个native方法，具体实现hotspot中，实现较为复杂，一般不需要特别关注。

## ClassLoader的实现类

![ClassLoader的实现类](./Classloader-UML.png)

ClassLoader是一个抽象类，它的实现类有很多，包括上一节中自定义的NetworkClassLoader，
jdk自带的URLClassLoader、AppClassLoader、ExtClassLoader等(jdk9以上类加载器实现有差异，无特殊说明均指jdk8，下同)。
一般我们只需要重写ClassLoader的findClass方法获取需要加载的类的字节码，然后调用defineClass方法生成Class对象。
如果想要在类加载到JVM中时就被链接，可以调用resolveClass，也可以选择交给JVM在类初始化时链接。

### URLClassLoader

URLClassLoader是ClassLoader的一个重要子类，它用于Jar文件和目录的URL的搜索路径加载类和资源。
它重写了findClass方法，findClass方法的作用就是从指定的url中去尝试加载类。
也就是说，通过URLClassLoader就可以加载指定jar中的class到内存中。
而class文件一般以jar包形式存在，因此使用URLClassLoader可以完成绝大多数场景的类和资源加载。

URLClassLoader的构造器参数是资源路径和父类加载器，构造器中主要是初始化URLClassPath对象。
```java
public URLClassLoader(URL[] urls, ClassLoader parent) {
    super(parent);
    // this is to make the stack depth consistent with 1.1
    SecurityManager security = System.getSecurityManager();
    if (security != null) {
        security.checkCreateClassLoader();
    }
    this.acc = AccessController.getContext();
    ucp = new URLClassPath(urls, acc);
}
```

下面是findClass的实现。
```java
protected Class<?> findClass(final String name) throws ClassNotFoundException
{
    final Class<?> result;
    try {
        result = AccessController.doPrivileged(
            new PrivilegedExceptionAction<Class<?>>() {
                public Class<?> run() throws ClassNotFoundException {
                    // 1、将类的全限定名变成.class文件路径的方式
                    String path = name.replace('.', '/').concat(".class");
                    // 2、在url中查找是否存在
                    Resource res = ucp.getResource(path, false);
                    if (res != null) {
                        try {
                            //3、如果存在则加载该类
                            return defineClass(name, res);
                        } catch (IOException e) {
                            throw new ClassNotFoundException(name, e);
                        }
                    } else {
                        return null;
                    }
                }
            }, acc);
    } catch (java.security.PrivilegedActionException pae) {
        throw (ClassNotFoundException) pae.getException();
    }
    if (result == null) {
        throw new ClassNotFoundException(name);
    }
    return result;
}
```
findClass方法的执行逻辑主要分为三步：

1、将类的全限定名变成.class文件路径的方式

2、在url中查找文件是否存在

3、如果存在则加载该类并调用defineClass

### jdk的类加载器

Java代码也需要使用类加载器来加载，下面的代码用来获取jdk内置的类加载器。
```java
public class JdkClassloader {
    public static void main(String[] args) {
        // 获取系统类加载器
        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
        System.out.println(systemClassLoader);
        
        // 获取系统类加载器的父类加载器 --> 扩展类加载器或者平台类加载器
        ClassLoader parent = systemClassLoader.getParent();
        System.out.println(parent);
        
        // 获取扩展类加载器的父类加载器 --> 根加载器（C/C++）
        ClassLoader parent1 = parent.getParent();
        System.out.println(parent1);
    }
}
```

在jdk8上运行：
```
sun.misc.Launcher$AppClassLoader@18b4aac2
sun.misc.Launcher$ExtClassLoader@4a574795
null
```

在jdk11上运行：
```
jdk.internal.loader.ClassLoaders$AppClassLoader@512ddf17
jdk.internal.loader.ClassLoaders$PlatformClassLoader@3cda1055
null
```
可以看到jdk8和jdk11类加载器的类名称不一样，下面分别说明其实现。

#### jdk8

##### AppClassloader
AppClassloader也称为System ClassLoader，是Java虚拟机默认的类加载器之一， 
主要用来加载用户类和第三方依赖包，负责加载应用程序classpath中的类，
同时它还支持根据用户设置来加载类，即通过设置-Djava.class.path参数来指定搜索路径。
```java
static class AppClassLoader extends URLClassLoader {
    
    public static ClassLoader getAppClassLoader(final ClassLoader extcl)
            throws IOException {
        // 搜索路径java.class.path
        final String s = System.getProperty("java.class.path");
        final File[] path = (s == null) ? new File[0] : getClassPath(s);

        URL[] urls = (s == null) ? new URL[0] : pathToURLs(path);
        return new AppClassLoader(urls, extcl);
    }

    /*
     * Creates a new AppClassLoader
     */
    AppClassLoader(URL[] urls, ClassLoader parent) {
        super(urls, parent, factory);
    }

    /**
     * 重写了loadClass，支持类的包权限检查
     */
    public Class<?> loadClass(String name, boolean resolve)
            throws ClassNotFoundException {
        int i = name.lastIndexOf('.');
        if (i != -1) {
            SecurityManager sm = System.getSecurityManager();
            if (sm != null) {
                sm.checkPackageAccess(name.substring(0, i));
            }
        }
        // 调用父类URLClassLoader完成类加载
        return (super.loadClass(name, resolve));
    }
    
    // 其他方法省略...
}    
```
##### ExtClassLoader

ExtClassLoader称为扩展类加载器，主要负责加载Java的扩展类库,默认加载${JAVA_HOME}/jre/lib/ext/
目录下的所有jar包或者由java.ext.dirs系统属性指定的jar包。
它加载时的搜索路径是由java.ext.dirs来决定的，该加载器在加载时不同于其他加载器，
它加载时会搜索指定路径下的所有子目录，也就是说它会搜索java.ext.dirs所指定下的所有子目录下的class文件或jar文件。
同时也可以用参数-Djava.ext.dirs来改变它的搜索路径。
```java
static class ExtClassLoader extends URLClassLoader {

    public static ExtClassLoader getExtClassLoader() throws IOException {
        final File[] dirs = getExtDirs();

        try {
            return new ExtClassLoader(dirs);
        } catch (java.security.PrivilegedActionException e) {
            throw (IOException) e.getException();
        }
    }
    
    public ExtClassLoader(File[] dirs) throws IOException {
        super(getExtURLs(dirs), null, factory);
    }

    private static File[] getExtDirs() {
        // 通过系统变量指定加载路径
        String s = System.getProperty("java.ext.dirs");
        File[] dirs;
        if (s != null) {
            StringTokenizer st =
                    new StringTokenizer(s, File.pathSeparator);
            int count = st.countTokens();
            dirs = new File[count];
            for (int i = 0; i < count; i++) {
                dirs[i] = new File(st.nextToken());
            }
        } else {
            dirs = new File[0];
        }
        return dirs;
    }
}    
```


#### jdk11

java9模块化之后，对classloader有所改造，其中一点就是将ExtClassLoader改为PlatformClassLoader，另外模块化之后对应的classloader加载各自对应的模块。
因为jdk11是一个长期支持的稳定版本，这里以jdk11的源代码来说明类加载器的变化。

JDK9 以上类加载器的继承关系：
![jdk9以上等待ClassLoader的层次](./JDK9-Classloader-UML.png)

BuiltinClassLoader是AppClassloader、PlatformClassLoader的父类，功能上与URLClassLoader相似，
都是基于UrlClassPath来实现类的查找，但BuiltinClassLoader支持从moudle加载class。
还有和通常的双亲委派不同，如果一个class属于某个moudle那么会直接调用该moudle的类加载器去加载，
而不是说直接用当前类加载器的双亲委派模型去加载。 但是找到这个class对应的类加载器后，还是会按照双亲委派去加载。

BuiltinClassLoader的构造器参数为
```java
BuiltinClassLoader(String name, BuiltinClassLoader parent, URLClassPath ucp) {
    // ensure getParent() returns null when the parent is the boot loader
    // name 是类加载器的名称
    super(name, parent == null || parent == ClassLoaders.bootLoader() ? null : parent);

    this.parent = parent;
    this.ucp = ucp;

    this.nameToModule = new ConcurrentHashMap<>();
    this.moduleToReader = new ConcurrentHashMap<>();
}
```

先来看下loadClassOrNull方法。
先判断是否已加载，若未加载，则寻找类所在模块，若找到该模块，则优先使用模块的类加载器加载；
若未加载，再向上寻找父类的类加载器。最后若没有找到，再根据classpath寻找
```
    protected Class<?> loadClassOrNull(String cn, boolean resolve) {
        synchronized (getClassLoadingLock(cn)) {
            // check if already loaded
            Class<?> c = findLoadedClass(cn);

            if (c == null) {

                // find the candidate module for this class
                LoadedModule loadedModule = findLoadedModule(cn);
                if (loadedModule != null) {

                    // package is in a module
                    BuiltinClassLoader loader = loadedModule.loader();
                    if (loader == this) {
                        if (VM.isModuleSystemInited()) {
                            c = findClassInModuleOrNull(loadedModule, cn);
                        }
                    } else {
                        // delegate to the other loader
                        c = loader.loadClassOrNull(cn);
                    }

                } else {

                    // check parent
                    if (parent != null) {
                        c = parent.loadClassOrNull(cn);
                    }

                    // check class path
                    if (c == null && hasClassPath() && VM.isModuleSystemInited()) {
                        c = findClassOnClassPathOrNull(cn);
                    }
                }

            }

            if (resolve && c != null)
                resolveClass(c);

            return c;
        }
    }
```

BuiltinClassLoader重写了ClassLoader的findClass方法：
```java
@Override
protected Class<?> findClass(String cn) throws ClassNotFoundException {
    // no class loading until VM is fully initialized
    if (!VM.isModuleSystemInited())
        throw new ClassNotFoundException(cn);

    // find the candidate module for this class
    LoadedModule loadedModule = findLoadedModule(cn);

    Class<?> c = null;
    if (loadedModule != null) {

        // attempt to load class in module defined to this loader
        //  加载任务委派给模块的加载器，而不是父加载器
        if (loadedModule.loader() == this) {
            c = findClassInModuleOrNull(loadedModule, cn);
        }

    } else {

        // search class path
        if (hasClassPath()) {
            c = findClassOnClassPathOrNull(cn);
        }

    }

    // not found
    if (c == null)
        throw new ClassNotFoundException(cn);

    return c;
}
```
##### BuiltinClassLoader的初始化以及子类

ClassLoaders类中定义了三个类加载器分别为BootClassLoader、PlatformClassLoader、AppClassLoader
BOOT_LOADER用来加载`jdk.boot.class.path.append`指定的类，在初始化PLATFORM_LOADER是指定BOOT_LOADER为其父类，
在初始化AppClassLoader是指定PLATFORM_LOADER为其父类，构成了类加载器的三层结构。
```text
public class ClassLoaders {

    // the built-in class loaders
    private static final BootClassLoader BOOT_LOADER;
    private static final PlatformClassLoader PLATFORM_LOADER;
    private static final AppClassLoader APP_LOADER;

    // Creates the built-in class loaders.
    static {
        // -Xbootclasspath/a or -javaagent with Boot-Class-Path attribute
        String append = VM.getSavedProperty("jdk.boot.class.path.append");
        BOOT_LOADER =
            new BootClassLoader((append != null && append.length() > 0)
                ? new URLClassPath(append, true)
                : null);
        // 指定AppClassLoader的父加载器BOOT_LOADER        
        PLATFORM_LOADER = new PlatformClassLoader(BOOT_LOADER);

        // A class path is required when no initial module is specified.
        // In this case the class path defaults to "", meaning the current
        // working directory.  When an initial module is specified, on the
        // contrary, we drop this historic interpretation of the empty
        // string and instead treat it as unspecified.
        String cp = System.getProperty("java.class.path");
        if (cp == null || cp.length() == 0) {
            String initialModuleName = System.getProperty("jdk.module.main");
            cp = (initialModuleName == null) ? "" : null;
        }
        URLClassPath ucp = new URLClassPath(cp, false);
        // 指定AppClassLoader的父加载器PLATFORM_LOADER
        APP_LOADER = new AppClassLoader(PLATFORM_LOADER, ucp);
    }
 }   
```

再来看下JDK9以上特有的PlatformClassLoader类：
```java
private static class PlatformClassLoader extends BuiltinClassLoader {
    static {
        if (!ClassLoader.registerAsParallelCapable())
            throw new InternalError();
    }

    PlatformClassLoader(BootClassLoader parent) {
        // 类加载器名称为platform
        super("platform", parent, null);
    }

    /**
     * Called by the VM to support define package for AppCDS.
     *
     * Shared classes are returned in ClassLoader::findLoadedClass
     * that bypass the defineClass call.
     */
    private Package definePackage(String pn, Module module) {
        return JLA.definePackage(this, pn, module);
    }
}
```

不同类的分工如下：
bootstrap classloader加载lib/modules
```text
java.base                   java.security.sasl
java.datatransfer           java.xml
java.desktop                jdk.httpserver
java.instrument             jdk.internal.vm.ci
java.logging                jdk.management
java.management             jdk.management.agent
java.management.rmi         jdk.naming.rmi
java.naming                 jdk.net
java.prefs                  jdk.sctp
java.rmi                    jdk.unsupported
```
platform classloader，加载lib/modules下的
```text
java.activation*            jdk.accessibility
java.compiler*              jdk.charsets
java.corba*                 jdk.crypto.cryptoki
java.scripting              jdk.crypto.ec
java.se                     jdk.dynalink
java.se.ee                  jdk.incubator.httpclient
java.security.jgss          jdk.internal.vm.compiler*
java.smartcardio            jdk.jsobject
java.sql                    jdk.localedata
java.sql.rowset             jdk.naming.dns
java.transaction*           jdk.scripting.nashorn
java.xml.bind*              jdk.security.auth
java.xml.crypto             jdk.security.jgss
java.xml.ws*                jdk.xml.dom
java.xml.ws.annotation*     jdk.zipfs
```
application classloader加载-cp，-mp指定的类
```
jdk.aot                     jdk.jdeps
jdk.attach                  jdk.jdi
jdk.compiler                jdk.jdwp.agent
jdk.editpad                 jdk.jlink
jdk.hotspot.agent           jdk.jshell
jdk.internal.ed             jdk.jstatd
jdk.internal.jvmstat        jdk.pack
jdk.internal.le             jdk.policytool
jdk.internal.opt            jdk.rmic
jdk.jartool                 jdk.scripting.nashorn.shell
jdk.javadoc                 jdk.xml.bind*
jdk.jcmd                    jdk.xml.ws*
jdk.jconsole
```

## 热加载与卸载

在类的加载过程中，我们知道会先检查该类是否已经加载，如果已经加载了，
则不会从jar包或者路径上查找类，而是使用缓存中的类。
JVM表示一个类是否是相同的类有2个条件：第一个是类的全限定名称是否相同，
第二个是类的加载器实例是否是同一个。 因此要实现类的热加载，可以使用不用的类加载器加载相同的类。

使用不同的类加载器实例加载同一个类，随着加载次数增加，类的个数也会不断增加，如果不及时清理元空间/永久代，会有内存益处的风险。
然而类卸载的条件非常苛刻，一般要同时具备下面的三个条件才可以卸载，并且需要JVM执行fullgc后才能完全清除干净。

类卸载的三个条件（来源于JVM虚拟机规范）：                       
 1.该类所有的实例都已经被GC。 

 2.加载该类的ClassLoader实例已经被GC。 

 3.该类的java.lang.Class对象没有在任何地方被引用。

FULL GC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的。

从上面的三个条件可以看出，JVM自带的类加载器不会被回收，因此JVM的类不会被卸载。只有自定义类加载器才有卸载的可能。

下面给出一个具体的需求，并使用热加载来完成。
应用在运行时加载一个class脚本，class脚本可以做到热更新。

有这样一个脚本接口，具有获取版本号和执行运算的功能
```java
public interface Script {
    // 获取脚本实现的版本
    String getVersion();
    
    // 执行运算
    String run(String key);

}
```

脚本的实现类，负责具体的计算功能。
```java
public class ScriptImpl implements Script {
    private static final String version = "1.0.0";

    public ScriptImpl() {
    }

    public String getVersion() {
        return "1.0.0";
    }

    public String run(String key) {
        return key;
    }
}

```

JVM 运行过程中替换脚本的实现，既可以实现脚本的更新功能。
```java
public class Main {
    public static void main(String[] args) throws Exception {
        ClassLoader appClassloader = Main.class.getClassLoader();

        ScriptClassLoader scriptClassLoader1 = new ScriptClassLoader("resources", appClassloader);
        Class<?> scriptImpl1 = scriptClassLoader1.loadClass("ScriptImpl");
        System.out.println(scriptImpl1.hashCode());

        ScriptClassLoader scriptClassLoader2 = new ScriptClassLoader("resources", appClassloader);
        Class<?> scriptImpl2 = scriptClassLoader2.loadClass("ScriptImpl");
        
        // class对象不相同
        assert scriptImpl1 != scriptImpl2;
    }
}
```
使用不同的类加载器还在同一个类，得到的class对象不一样。运行时更新 ScriptImpl 类的实现即可

ScriptClassLoader的实现如下：
```text
public class ScriptClassLoader extends ClassLoader {
    private String classDir;

    public ScriptClassLoader(String classDir,ClassLoader classLoader) {
        super(classLoader);
        this.classDir = classDir;
    }

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] classDate = getDate(name);
            if (classDate == null) {
                return null;
            }
            return defineClass(name, classDate, 0, classDate.length);
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private byte[] getDate(String className) throws IOException {
        InputStream in = null;
        ByteArrayOutputStream out = null;
        String path = classDir + File.separatorChar +
                className.replace('.', File.separatorChar) + ".class";
        try {
            in = new FileInputStream(path);
            out = new ByteArrayOutputStream();
            byte[] buffer = new byte[2048];
            int len = 0;
            while ((len = in.read(buffer)) != -1) {
                out.write(buffer, 0, len);
            }
            return out.toByteArray();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            in.close();
            out.close();
        }
        return null;
    }
}
```

## web类加载器

前面介绍了java中类加载的一般模型：双亲委派模型，这个模型适用于大多数类加载的场景，
但对于web容器却是不适用的；这是因为servlet规范对web容器的类加载做了一些规定，简单的来说有以下几条：

1.WEB-INF/classes和WEB-INF/lib路径下的类会优先于父容器中的类加载，比如WEB-INF/classes下有个ABC类，CLASSPATH下也有个ABC类，jetty会优先加载WEB-INF/classes下的，这与双亲委托模型下的加载行为相反。
2.java.lang.Object等系统类不遵循第一条， WEB-INF/classes或WEB-INF/lib中的类不能替换系统类。对于哪些是系统类，其实没有做出具体规定，jetty中是通过枚举了一些类来进行判断的。
3.Server容器的实现类不被应用中的类引用，即Server的实现类不能被任何应用类加载器加载。对于哪些是系统类，也是通过枚举类的全限定名来实现的。

### jetty

为了实现上面的三个要求并实现不同部署应用间依赖的隔离，jetty定义了自己的类加载器WebAppClassLoader，通过对这个类加载器使用线程上下文加载模式来达到目的。

WebAppClassLoader的属性
```text
    private final Context _context;     // 类加载器上下文
    private final ClassLoader _parent;  // 父加载器
    private final Set<String> _extensions = new HashSet<String>(); // 加载文件的后缀
    private String _name = String.valueOf(hashCode()); // 加载器名称
    private final List<ClassFileTransformer> _transformers = new CopyOnWriteArrayList<>(); // 类加载之前转换器
```

jetty规定的系统类和jetty自身的基础类如下，如果是这些类将不使用WebAppClassLoader加载

```text
    // System classes are classes that cannot be replaced by
    // the web application, and they are *always* loaded via
    // system classloader.
    public static final ClassMatcher __dftSystemClasses = new ClassMatcher(
        "java.",                            // Java SE classes (per servlet spec v2.5 / SRV.9.7.2)
        "javax.",                           // Java SE classes (per servlet spec v2.5 / SRV.9.7.2)
        "org.xml.",                         // javax.xml
        "org.w3c."                          // javax.xml
    );

    // Server classes are classes that are hidden from being
    // loaded by the web application using system classloader,
    // so if web application needs to load any of such classes,
    // it has to include them in its distribution.
    public static final ClassMatcher __dftServerClasses = new ClassMatcher(
        "org.eclipse.jetty."                // hide jetty classes
    );

    private final ClassMatcher _systemClasses = new ClassMatcher(__dftSystemClasses);
    private final ClassMatcher _serverClasses = new ClassMatcher(__dftServerClasses);

```

判断是否是parent优先模式由WebAppContext中的一段来解决：
```text
    private boolean _parentLoaderPriority = Boolean.getBoolean("org.eclipse.jetty.server.webapp.parentLoaderPriority");
     
     /**
     * @return True if the classloader should delegate first to the parent
     * classloader (standard java behaviour) or false if the classloader
     * should first try to load from WEB-INF/lib or WEB-INF/classes (servlet
     * spec recommendation). Default is false or can be set by the system
     * property org.eclipse.jetty.server.webapp.parentLoaderPriority
     */
    @Override
    @ManagedAttribute(value = "parent classloader given priority", readonly = true)
    public boolean isParentLoaderPriority()
    {
        return _parentLoaderPriority;
    }
```

构造器
```text
    public WebAppClassLoader(Context context)
        throws IOException
    {
        this(null, context);
    }
    
    // 父加载器
    // 加载器上下文 
    public WebAppClassLoader(ClassLoader parent, Context context)
        throws IOException
    {
        super(new URL[]{}, parent != null ? parent
            : (Thread.currentThread().getContextClassLoader() != null ? Thread.currentThread().getContextClassLoader()
            : (WebAppClassLoader.class.getClassLoader() != null ? WebAppClassLoader.class.getClassLoader()
            : ClassLoader.getSystemClassLoader())));
        // 如果在构建的时候没有提供父亲classLoader，那么将会默认将当前的线程classLoader作为当前的父classLoader      
        _parent = getParent(); // 获取上面设置的父加载器
        _context = context; // 保存上下文
        if (_parent == null)
            throw new IllegalArgumentException("no parent classloader!");
        
        // 类加载器可以加载的文件类型：jar或者zip包    
        _extensions.add(".jar");
        _extensions.add(".zip");

        if (context.getExtraClasspath() != null)
        {
            for (Resource resource : context.getExtraClasspath())
            {
                addClassPath(resource);
            }
        }
    }
```

其实这里一般情况下都是会调用第一个构造函数，
第二个构造函数可以显示指定父类加载器，这里默认是将当前的线程上下文classLoader指定为当前的parent，
而这个线程上下文classLoader如果没有用户指定的话默认又将是前面提到过的appClassLoader，也就是用于加载用户代码的classLoader。。。。

在看下 loadclass 方法：
```text
    @Override
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name))
        {
            ClassNotFoundException ex = null;
            Class<?> parentClass = null; // 来源于父加载器
            Class<?> webappClass = null; // 来源于webapp加载器

            // Has this loader loaded the class already?
            // 先从已经加载的类正经查找  
            webappClass = findLoadedClass(name);
            if (webappClass != null)
            {
                return webappClass;
            }

            // 是否父类加载器优先加载
            if (_context.isParentLoaderPriority())
            {
                // Try the parent loader
                try
                {   
                    // 从父类加载加载
                    parentClass = _parent.loadClass(name);
                    if (parentClass == null)
                        throw new ClassNotFoundException("Bad ClassLoader: returned null for loadClass(" + name + ")");

                    // If the webapp is allowed to see this class
                    // 如果设置了子类可以看见父类，返回父类
                    if (Boolean.TRUE.equals(__loadServerClasses.get()) || !_context.isServerClass(parentClass))
                    {
                        return parentClass;
                    }
                }
                catch (ClassNotFoundException e)
                {
                    // Save it for later
                    ex = e;
                }

                // Try the webapp loader
                try
                {
                    // 从类加载器的路径下查找类
                    webappClass = this.findClass(name);
                    if (resolve)
                        resolveClass(webappClass);
                    return webappClass;
                }
                catch (ClassNotFoundException e)
                {
                    if (ex == null)
                        ex = e;
                    else if (e != ex)
                        ex.addSuppressed(e);
                }

                throw ex;
            }
            else
            // 先从子类加载器加载
            {
                // Not parent loader priority, so...
                webappClass = loadAsResource(name, true);
                if (webappClass != null)
                {
                    return webappClass;
                }
                        
                // Try the parent loader
                // 子类未加载，父类加载器加载
                try
                {
                    parentClass = _parent.loadClass(name);
                    // If the webapp is allowed to see this class
                    if (Boolean.TRUE.equals(__loadServerClasses.get()) || !_context.isServerClass(parentClass))
                    {
                        return parentClass;
                    }
                }
                catch (ClassNotFoundException e)
                {
                    ex = e;
                }

                // We couldn't find a parent class, so OK to return a webapp one if it exists 
                // and we just couldn't see it before 
                webappClass = loadAsResource(name, false);
                if (webappClass != null)
                {
                    return webappClass;
                }

                throw ex == null ? new ClassNotFoundException(name) : ex;
            }
        }
    }
```

jar包添加
```text
    /**
     * Add elements to the class path for the context from the jar and zip files found
     * in the specified resource.
     *
     * @param lib the resource that contains the jar and/or zip files.
     */
    public void addJars(Resource lib)
    {
        if (lib.exists() && lib.isDirectory())
        {
            String[] entries = lib.list();
            if (entries != null)
            {
                Arrays.sort(entries);

                for (String entry : entries)
                {
                    try
                    {
                        Resource resource = lib.addPath(entry);
                        if (LOG.isDebugEnabled())
                            LOG.debug("addJar - {}", resource);
                        String fnlc = resource.getName().toLowerCase(Locale.ENGLISH);
                        // don't check if this is a directory (prevents use of symlinks), see Bug 353165
                        if (isFileSupported(fnlc)) // .jar、.zip
                        {
                            String jar = URIUtil.encodeSpecific(resource.toString(), ",;");
                            addClassPath(jar);
                        }
                    }
                    catch (Exception ex)
                    {
                        LOG.warn("Unable to load WEB-INF/lib JAR {}", entry, ex);
                    }
                }
            }
        }
    }
```



https://baijiahao.baidu.com/s?id=1600064255906644546&wfr=spider&for=pc

https://blog.csdn.net/chen_fly2011/article/details/56016338

## 本章小结

本章先介绍了类加载器的API使用，类加载器的源码解析，以及JVM自带的类加载器的实现，
并详细分析了不同JDK的差异性，最后介绍了类的热加载技术原理，并给出一个实际的热加载例子。